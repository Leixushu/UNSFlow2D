module grid
implicit none

integer(kind=4):: np,nf,nc 

type points 
     real(kind=8) :: x,y,z
     integer(kind=4):: bc,flag,nv2c 
     integer(kind=4),dimension(:),pointer::v2c
end type points 

type faces  
     integer(kind=4):: pt(2) 
     integer(kind=4):: bc,flag,in,out 
     real(kind=8)   :: sx,sy 
end type faces  

type cells  
     integer(kind=4):: nc2v,nc2f,nc2c  
     real(kind=8)   :: xc,yc,zc,cv
     integer(kind=4),dimension(:),pointer::c2v
     integer(kind=4),dimension(:),pointer::c2f
     integer(kind=4),dimension(:),pointer::c2c
end type cells  

type(points),dimension(:),pointer::pt
type(points),dimension(:,:),pointer::mesh
type(faces),dimension(:),pointer::fc
type(cells),dimension(:),pointer::cell

end module grid
!========================================================
program SolverMesh
use grid
implicit none
integer(kind=4) :: i,j,k
integer(kind=4) :: nop,noc,nof
integer(kind=4) :: e1,e2,c,f1
!real(kind=8)    :: x1,y1,x2,y2
!real(kind=8)    :: xc,yc
real(kind=8)    :: check

type(points),pointer,dimension(:)::node
type(faces),pointer,dimension(:)::face
type(cells),pointer,dimension(:)::elem
type(cells),pointer,dimension(:)::elem0


!noc=100

open(13,file='geometry.inp')
read(13,*)nop,noc,nof

allocate(node(nop),face(nof),elem(noc))

print*,nop,noc,nof
do i=1,nop
  read(13,*)j,node(i)%x,node(i)%y,node(i)%bc
enddo
do i=1,noc
 read(13,*)j,elem(i)%xc,elem(i)%yc,elem(i)%cv
enddo
do i=1,nof
 read(13,*)j,face(i)%pt(1),face(i)%pt(2),face(i)%in,face(i)%out,&
                       face(i)%sx,face(i)%sy,face(i)%bc
enddo
close(13)



allocate(elem0(noc))

elem0(:)%nc2c=0
do i=1,nof
   e1=face(i)%in
   e2=face(i)%out
 
   if(e1/=0.and.e2/=0) then

     c=0
     do j=1,elem0(e1)%nc2c
        if(elem0(e1)%c2c(j)==e2) c=c+1  
     enddo

     if(c==0) then 
       elem0(e1)%nc2c=elem0(e1)%nc2c+1
       call alloc_int_ptr(elem0(e1)%c2c,elem0(e1)%nc2c)      
       elem0(e1)%c2c(elem0(e1)%nc2c)=e2      
     endif


     c=0
     do j=1,elem0(e2)%nc2c
        if(elem0(e2)%c2c(j)==e1) c=c+1  
     enddo

     if(c==0) then 
       elem0(e2)%nc2c=elem0(e2)%nc2c+1
       call alloc_int_ptr(elem0(e2)%c2c,elem0(e2)%nc2c)      
       elem0(e2)%c2c(elem0(e2)%nc2c)=e1      
     endif


   endif
   
enddo

!===========================================================================
!                      Allocate/extend array
!===========================================================================

contains

subroutine alloc_int_ptr(x,n)
use grid
implicit none
integer(kind=4),intent(in) ::n 
integer(kind=4)::i 
integer(kind=4),dimension(:),pointer::temp
integer(kind=4),dimension(:),pointer::x

if (n <= 0) then
 write(*,*) "my_alloc_int_ptr received non-positive dimension. Stop."
 stop
endif

! If not allocated, allocate and return
if (.not.(associated(x))) then
 allocate(x(n))
 return
endif

! If reallocation, create a pointer with a target of new dimension.
allocate(temp(n))

! (1) Expand the array dimension
if ( n > size(x) ) then
   do i = 1, size(x)
      temp(i) = x(i)
   end do

! (2) Shrink the array dimension: the extra data, x(n+1:size(x)), discarded.
else
   do i = 1, n
      temp(i) = x(i)
   end do
endif

! Destroy the target of x
!  deallocate(x)

! Re-assign the pointer
 x => temp

deallocate(temp)

return

end subroutine alloc_int_ptr

function dotprod(n1,n2,xc,yc)
   implicit none
   integer*4:: n1,n2
   real*8   :: x1,y1,x2,y2
   real*8   :: dx,dy,ds,xc,yc
   real*8   :: dotprod,nx,ny,rx,ry


   x1 = node(n1)%x ; y1 = node(n1)%y
   x2 = node(n2)%x ; y2 = node(n2)%y
   dx = x2-x1 ; dy = y2-y1
   ds = dsqrt(dx*dx+dy*dy)
   nx = dy/ds ; ny = -dx/ds

   dx = xc-x1 ; dy = yc-y1
   ds = dsqrt(dx*dx+dy*dy)
   rx = dx/ds
   ry = dy/ds
   dotprod = rx*nx+ry*ny

end function dotprod


function crossprod(n1,n2,m1,m2)
   implicit none
   integer*4:: n1,n2,m1,m2
   real*8   :: x1,y1,x2,y2
   real*8   :: x3,y3,x4,y4
   real*8   :: dx,dy,ds
   real*8   :: crossprod,nx,ny,rx,ry


   x1 = node(n1)%x ; y1 = node(n1)%y
   x2 = node(n2)%x ; y2 = node(n2)%y

   x3 = node(m1)%x ; y3 = node(m1)%y
   x4 = node(m2)%x ; y4 = node(m2)%y

   dx = x2-x1 ; dy = y2-y1
   ds = dsqrt(dx*dx+dy*dy)
   nx = dy/ds ; ny = -dx/ds

   dx = x4-x3 ; dy = y4-y3
   ds = dsqrt(dx*dx+dy*dy)
   rx = dx/ds
   ry = dy/ds

   crossprod = nx*ry-ny*rx

end function crossprod


end program SolverMesh
